"""   codex.py   Used to query from and post build information to Codex Web Service   Written by: Marc Kubischta, Eric Robinson   Contributions from: Jochen Hagenstrom, Chris Loveless, Gorav Singal"""import sys, os.path, shutil, timefrom xml.dom.minidom import parseStringimport codexdatatypes as datatypesfrom suds.client import Client#webserviceserver = "https://codex-stg.corp.adobe.com"webserviceserver = "https://codex.corp.adobe.com"class CodexService(object):   """      Class used to connect to Codex web service.      See https://zerowing.corp.adobe.com/display/codex/Codex+2.0+API+Specification   """   def __init__(self, tracefile=None, timeout=10):      """         The init method.  The web service has one WSDL file that is of interest         to us, codex.wsdl. Both methods for posting and retrieving information         via Codex are defined by it.         Arguments:            tracefile - An optional argument. If a file path is given, then               a trace of each request and response will be written to               the file.  Any data previously in the file before the               service was initialized will be overwritten.            timeout - Optional.  Specifies a length of time (in seconds) to               try connecting to the server.  If set to zero, only one               attempt will be made.  Default is 300s (5 minutes).      """      # First, see if there's a ".service_proxy_dir folder, and delete it.      # Otherwise, ZSI will always go there for the WSDL instead of looking      # to the server      if os.path.isdir(".service_proxy_dir"):         shutil.rmtree(".service_proxy_dir")      wsdlfile = "%s/codex/codex.wsdl" % (webserviceserver)      print "Server using: %s" %wsdlfile      inittime = time.time()      counter = 0      version='unknown'      build_no='unknown'	      if os.path.exists(os.path.dirname(__file__)+os.sep+'application.codex-python-client.properties'):         file=open(os.path.dirname(__file__)+os.sep+'application.codex-python-client.properties','r')	 for line in file:           if '=' in line:	       if line.split('=')[0] == 'codex.version':		   version = line.split('=')[1].strip()	       else:                  if line.split('=')[0] == 'codex.buildnumber':                     build_no = line.split('=')[1].strip()					      userAgent='Client=CodexSoapPythonClient, Version='+version+', BuildNumber='+build_no	      while True:         try:            counter += 1            self._server = Client(wsdlfile, location=wsdlfile, headers={'user-agent': userAgent, 'Connection':'Keep-Alive'}).service                        break         except:            currenttime = time.time()            if (currenttime - inittime) > float(timeout):               print "Could not connect to server after %d attempts." % (counter)               raise            else:               time.sleep(5)                  # product class   def getProducts(self):      'returns a list of Products'      try:         result = self._server.GetProducts(val='')      except Exception, e:         _handleException(e)      return _getProductListFromNode(result['productlist'])   def getProductByName(self, name):      'returns a Product with the matching name'      try:         result = self._server.GetProductByName(productname=name)      except Exception, e:         _handleException(e)      return _getProductFromNode(result['product'])   def getProductByID(self, id):      'returns a Product with the matching id'      id = int(id)      try:         result = self._server.GetProductById(productid=id)      except Exception, e:         _handleException(e)      return _getProductFromNode(result['product'])   def addProduct(self, name, type, user, password, ticket=None):      'creates a product of the given name and type and returns the id as an int'      try:         result = self._server.AddProduct(productname=name, producttypename=type, ldapcredentials={'userid':user, 'password':password})      except Exception, e:         _handleException(e)      return result['productid']         def deleteProduct(self, id, user, password, ticket=None):      'deletes a product by id and returns a boolean success result'      id=int(id)      try:         result = self._server.DeleteProduct(productid=id, ldapcredentials={'userid':user, 'password':password})      except Exception, e:         _handleException(e)      return result['operationresult']         def setProductType(self, id, type, user, password, ticket=None):      "updates a product's type and returns the updated Product"      id = int(id)      try:         result = self._server.SetProductType(productid=id, producttypename=type, ldapcredentials={'userid':user, 'password':password})      except Exception, e:         _handleException(e)      return _getProductFromNode(result['product'])         def setProductLink(self, id, link, user, password, ticket=None):      "updates a product's link and returns the updated Product"      id = int(id)      try:         result = self._server.SetProductLink(productid=id, link=link, ldapcredentials={'userid':user, 'password':password})      except Exception, e:         _handleException(e)      return _getProductFromNode(result['product'])   def setProductDescription(self, id, description, user, password, ticket=None):      "updates a product's description and returns the updated Product"      id = int(id)      try:         result = self._server.SetProductDescription(productid=id, description=description, ldapcredentials={'userid':user, 'password':password})      except Exception, e:         _handleException(e)      return _getProductFromNode(result['product'])      def setProductName(self, id, name, user, password, ticket=None):      "updates a product's name and returns the updated Product"      id = int(id)      try:         result = self._server.SetProductName(productid=id, productname=name, ldapcredentials={'userid':user, 'password':password})      except Exception, e:         _handleException(e)      return _getProductFromNode(result['product'])   # subproduct   def addSubproduct(self, name, product, version, user, password):      "adds a subproduct and returns the new id"      try:         result = self._server.AddSubproduct(subproductname=name, productname=product, versionname=version, ldapcredentials={'userid':user, 'password':password})      except Exception, e:         _handleException(e)      return result['id']      try:         result = self._server.GetAllSubproducts(val='')      except Exception, e:         _handleException(e)      return _getSubproductListFromNode(result['subproductlist'])   def getSubproducts(self, product, version):      "gets a list of the subproducts of a particular product version"      try:         result = self._server.GetSubproducts(productname=product, versionname=version)      except Exception, e:         _handleException(e)      return _getSubproductListFromNode(result['subproductlist'])   def getSubproductByName(self, name, product, version):      "gets a specific subproduct from a particular product version"      try:         result = self._server.GetSubproductByName(subproductname=name, productname=product, versionname=version)      except Exception, e:         _handleException(e)      return _getSubproductFromNode(result['subproduct'])   def getSubproductByID(self, id):      "gets a specific subproduct by its id"      id = int(id)      try:         result = self._server.GetSubproductById(id=id)      except Exception, e:         _handleException(e)      return _getSubproductFromNode(result['subproduct'])   def setSubproductDescription(self, id, description, user, password):      "sets a subproduct's description and returns the updated subproduct"      id = int(id)      try:         result = self._server.SetSubproductDescription(id=id, description=description, ldapcredentials={'userid':user, 'password':password})      except Exception, e:         _handleException(e)      return _getSubproductFromNode(result['subproduct'])   def setSubproductName(self, id, name, user, password):      "sets a subproduct's name and returns the updated subproduct"      id = int(id)      try:         result = self._server.SetSubproductName(id=id, subproductname=name, ldapcredentials={'userid':user, 'password':password})      except Exception, e:         _handleException(e)      return _getSubproductFromNode(result['subproduct'])   def deleteSubproduct(self, id, user, password):      "deletes a subproduct by id and returns the operation result"      id = int(id)      try:         result = self._server.DeleteSubproduct(id=id, ldapcredentials={'userid':user, 'password':password})      except Exception, e:         _handleException(e)      return result['operationresult']   # version class      def getVersions(self, product):      'returns a list of Versions in the given product'      try:         result = self._server.GetVersions(productname=product)      except Exception, e:         _handleException(e)      return _getVersionListFromNode(result['versionlist'])   def getAllVersions(self):      'returns a list of all Versions'      try:         result = self._server.GetAllVersions(val='')      except Exception, e:         _handleException(e)      return _getVersionListFromNode(result['versionlist'])   def getVersionByName(self, product, version):      'returns a Version by name'      try:         result = self._server.GetVersionByName(productname=product, versionname=version)      except Exception, e:         _handleException(e)      return _getVersionFromNode(result['version'])   def getVersionByID(self, id):      'returns a Version having the specified version id'      id=int(id)      try:         result = self._server.GetVersionById(versionid=id)      except Exception, e:         _handleException(e)      return _getVersionFromNode(result['version'])   def addVersion(self, product, version, user, password, ticket=None):      'creates a new version and returns its id as an int'      try:         result = self._server.AddVersion(productname=product, versionname=version, ldapcredentials={'userid':user, 'password':password})      except Exception, e:         _handleException(e)      return result['versionid']   def deleteVersion(self, id, user, password, ticket=None):      'deletes a version by id and returns a boolean success result'      id=int(id)      try:         result = self._server.DeleteVersion(versionid=id, ldapcredentials={'userid':user, 'password':password})      except Exception, e:         _handleException(e)      return result['operationresult']   def setVersionCodeName(self, id, codename, user, password, ticket=None):      "updates a version's codename and returns the updated Version"      id=int(id)      try:         result = self._server.SetVersionCodeName(versionid=id, versioncodename=codename, ldapcredentials={'userid':user, 'password':password})      except Exception, e:         _handleException(e)      return _getVersionFromNode(result['version'])   def setVersionLink(self, id, link, user, password, ticket=None):      "updates a version's link and returns the updated Version"      id=int(id)      try:         result = self._server.SetVersionLink(versionid=id, link=link, ldapcredentials={'userid':user, 'password':password})      except Exception, e:         _handleException(e)      return _getVersionFromNode(result['version'])   def setVersionDescription(self, id, description, user, password, ticket=None):      "updates a version's description and returns the updated Version"      id=int(id)      try:         result = self._server.SetVersionDescription(versionid=id, description=description, ldapcredentials={'userid':user, 'password':password})      except Exception, e:         _handleException(e)      return _getVersionFromNode(result['version'])   def setVersionName(self, id, name, user, password, ticket=None):      "updates a version's name and returns the updated Version"      id=int(id)      try:         result = self._server.SetVersionName(versionid=id, versionname=name, ldapcredentials={'userid':user, 'password':password})      except Exception, e:         _handleException(e)      return _getVersionFromNode(result['version'])   # certification level      def getCertLevels(self):      'returns a list of all CertLevels in codex'      try:         result = self._server.GetCertificationLevels(val='')      except Exception, e:         _handleException(e)      return _getCertLevelListFromNode(result['certificationlevellist'])   def getCertLevelByName(self, name):      'returns a codex CertLevel referenced by name'      try:         result = self._server.GetCertificationLevelByName(name=name)      except Exception, e:         _handleException(e)      return _getCertLevelFromNode(result['certificationlevel'])   def getCertLevelByID(self, id):        'returns a codex CertLevel referenced by int id'      id=int(id)      try:         result = self._server.GetCertificationLevelById(id=id)      except Exception, e:         _handleException(e)      return _getCertLevelFromNode(result['certificationlevel'])   # Status   def getStatuses(self):      'returns a list of all Statuses in codex'      try:         result = self._server.GetStatuses(val='')      except Exception, e:         _handleException(e)      return _getStatusListFromNode(result['statuslist'])   def getStatusByName(self, name):      'returns a codex Status referenced by name'      try:         result = self._server.GetStatusByName(statusname=name)      except Exception, e:         _handleException(e)      return _getStatusFromNode(result['status'])   def getStatusByID(self, id):      'returns a codex Status referenced by int id'      id=int(id)      try:         result = self._server.GetStatusById(id=id)      except Exception, e:         _handleException(e)      return _getStatusFromNode(result['status'])   # Compiler Target   def getCompilerTargets(self):      'returns a list of all CompilerTargets in codex'      try:         result = self._server.GetCompilerTargets(val='')      except Exception, e:         _handleException(e)      return _getCompilerTargetListFromNode(result['compilertargetlist'])   def getCompilerTargetByName(self, name):      'returns a codex CompilerTarget referenced by name'      try:         result = self._server.GetCompilerTargetByName(name=name)      except Exception, e:         _handleException(e)      return _getCompilerTargetFromNode(result['compilertarget'])   def getCompilerTargetByID(self, id):      'returns a codex CompilerTarget referenced by int id'      id=int(id)      try:         result = self._server.GetCompilerTargetById(id=id)      except Exception, e:         _handleException(e)      return _getCompilerTargetFromNode(result['compilertarget'])   # License Model   def getLicenseModels(self):      'returns a list of all LicenseModels in codex'      try:         result = self._server.GetLicenseModels(val='')      except Exception, e:         _handleException(e)      return _getLicenseModelListFromNode(result['licensemodellist'])   def getLicenseModelByName(self, name):      'returns a codex LicenseModel referenced by name'      try:         result = self._server.GetLicenseModelByName(name=name)      except Exception, e:         _handleException(e)      return _getLicenseModelFromNode(result['licensemodel'])   def getLicenseModelByID(self, id):      'returns a codex LicenseModel referenced by int id'      id=int(id)      try:         result = self._server.GetLicenseModelById(id=id)      except Exception, e:         _handleException(e)      return _getLicenseModelFromNode(result['licensemodel'])   # Format   def getFormats(self):      'returns a list of all Formats in codex'      try:         result = self._server.GetFormats(val='')      except Exception, e:         _handleException(e)      return _getFormatListFromNode(result['formatlist'])   def getFormatByName(self, name):      'returns a codex Format referenced by name'      try:         result = self._server.GetFormatByName(name=name)      except Exception, e:         _handleException(e)      return _getFormatFromNode(result['format'])   def getFormatByID(self, id):      'returns a codex Format referenced by int id'      id=int(id)      try:         result = self._server.GetFormatById(id=id)      except Exception, e:         _handleException(e)      return _getFormatFromNode(result['format'])   # Platforms   def getPlatforms(self):      'returns a list of all Platforms in codex'      try:         result = self._server.GetPlatforms(val='')      except Exception, e:         _handleException(e)      return _getPlatformListFromNode(result['platformlist'])   def getPlatformByName(self, name):      'returns a codex Platform referenced by name'      try:         result = self._server.GetPlatformByName(name=name)      except Exception, e:         _handleException(e)      return _getPlatformFromNode(result['platform'])   def getPlatformByID(self, id):      'returns a codex Platform referenced by int id'      id=int(id)      try:         result = self._server.GetPlatformById(id=id)      except Exception, e:         _handleException(e)      return _getPlatformFromNode(result['platform'])   # Platform Groups   def getPlatformGroups(self, product, version):      'returns PlatformGroups for the given product/version'      try:         result = self._server.GetPlatformgroups(productname=product, versionname=version)      except Exception, e:         _handleException(e)      return _getPlatformGroupListFromNode(result['platformgrouplist'])   def getPlatformGroupByName(self, product, version, name):      'returns a PlatformGroup by name from the given product/version'      try:         result = self._server.GetPlatformgroupByName(productname=product, versionname=version, platformgroupname=name)      except Exception, e:         _handleException(e)      return _getPlatformGroupFromNode(result['platformgroup'])   def getPlatformGroupByID(self, id):      'returns a PlatformGroup by id from the given product/version'      id=int(id)      try:         result = self._server.GetPlatformgroupById(id=id)      except Exception, e:         _handleException(e)      return _getPlatformGroupFromNode(result['platformgroup'])   def addPlatformGroup(self, product, version, name, username, password):      'adds a PlatformGroup to the given product/version'      try:         result = self._server.AddPlatformgroup(productname=product, versionname=version, platformgroupname=name,            ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['id']   def deletePlatformGroup(self, id, username, password):      'removes a PlatformGroup by ID'      id=int(id)      try:         result = self._server.DeletePlatformgroup(id=id, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['operationresult']   def addPlatformGroupPlatform(self, id, platform, username, password):      'adds a platform by name to the PlatformGroup specified by id'      id=int(id)      try:         result = self._server.AddPlatformgroupPlatform(id=id, platformname=platform,            ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['id']   def deletePlatformGroupPlatform(self, id, platform, username, password):      'removes a platform by name from the PlatformGroup specified by id'      id=int(id)      try:         result = self._server.DeletePlatformgroupPlatform(id=id, platformname=platform,            ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['operationresult']   # Contacts   def getContacts(self, product, version):      "Gets the list of Contacts in Codex for the given Product/Version"      try:         result = self._server.GetContacts(versionname=version, productname=product)      except Exception, e:         _handleException(e)      return _getContactListFromNode(result['contactlist'])   def getContactByName(self, product, version, name):      "Gets the Contact record for the given Product/Version, by name"      try:         result = self._server.GetContactByName(versionname=version, productname=product, contactname=name)      except Exception, e:         _handleException(e)      return _getContactFromNode(result['contact'])   def getContactTypes(self):      "Gets a list of Contact Types defined in Codex"      try:         result = self._server.GetContacttypes(val='')      except Exception, e:         _handleException(e)      return _getContactTypeListFromNode(result['contacttypelist'])   def addContact(self, product, version, name, type, username, password):      "Adds a new Contact record to Codex for the given product/version"      try:         result = self._server.AddContact(contactname=name, contacttypename=type,             versionname=version, productname=product, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['id']   def deleteContact(self, id, username, password):      "Deletes a contact from Codex"      id=int(id)      try:         result = self._server.DeleteContact(id=id, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['operationresult']   # Languages   def getLanguages(self):      'returns a list of all Languages in codex'      try:         result = self._server.GetLanguages(var='')      except Exception, e:         _handleException(e)      return _getLanguageListFromNode(result['languagelist'])   def getLanguageByName(self, name):      'returns a codex Language referenced by name'      try:         result = self._server.GetLanguageByName(name=name)      except Exception, e:         _handleException(e)      return _getLanguageFromNode(result['language'])   def getLanguageByID(self, id):      'returns a codex Language referenced by int id'      id = int(id)      try:         result = self._server.GetLanguageById(id=id)      except Exception, e:         _handleException(e)      return _getLanguageFromNode(result['language'])   def getLanguageByCode(self, code):      'returns a codex Language referenced by iso code'      try:         result = self._server.GetLanguageByCode(languagecode=code)      except Exception, e:         _handleException(e)      return _getLanguageFromNode(result['language'])   # Product Types   def getProductTypes(self):      "Gets a list of all Producttypes defined in Codex"      try:         result = self._server.GetProducttypes(val='')      except Exception, e:         _handleException(e)      return _getProductTypeListFromNode(result['producttypelist'])   def getProductTypeByName(self, name):      "Gets a product type by name"      try:         result = self._server.GetProducttypeByName(producttypename=name)      except Exception, e:         _handleException(e)      return _getProductTypeFromNode(result['producttype'])   def getProductTypeByID(self, id):      "Gets a product type by its ID"      id=int(id)      try:         result = self._server.GetProducttypeById(id=id)      except Exception, e:         _handleException(e)      return _getProductTypeFromNode(result['producttype'])   # Pickup Options   def getPickupOptions(self):      "Gets a list of all PickupOptions defined in Codex"      try:         result = self._server.GetPickupOptions(val='')      except Exception, e:         _handleException(e)      return _getPickupOptionListFromNode(result['pickupoptionlist'])   # Servers   def getServers(self):      "Gets a list of all Servers defined in Codex."      try:         result = self._server.GetServers(val='')      except Exception, e:         _handleException(e)      return _getServerListFromNode(result['serverlist'])   def getServerByName(self, servername):      "Gets a Server record by name."      try:         result = self._server.GetServerByName(servername=servername)      except Exception, e:         _handleException(e)      return _getServerFromNode(result['server'])   def getServerByID(self, id):      "Gets a Server record by unique ID."      id = int(id)      try:         result = self._server.GetServerById(id=id)      except Exception, e:         _handleException(e)      return _getServerFromNode(result['server'])   # Builds   def getLatestBuild(self, product='', version='', subproduct='', build='', platform='', language='', compiletarget='', licensing='',      format='', certlevel='', status='', date='', metadata=''):      """         get a single Build meeting specific criteria         product        String  Name of a current product         version        String  Name of a current version of the given product         build          String  Name of a current build of the given product         platform       String  Name of a current Platform in Codex         language       String  Name of a current language in Codex         compiletarget  String  Name of a valid compile target value         licensing      String  Name of a valid licensing value         format         String  Name of a valid format value         certlevel      String  Name of a valid Certification Level         status         String  Name of a valid status         date           String  A date to filter by, of the form YYYY/MM/DD or YYYY/MM/DD:HH:MM:SS (same as Perforce)         metadata       String  A set of key/value pairs concatenated together "key1=value1:key2=value2"      This is the most complex method in the API aside from postBuild. This is         the primary method for querying Codex for a set of builds with an arbitrary         set of parameters. As such, each parameter accepts a variety of values:   1. A fixed value.         The method will search the database for an exact match.   2. A wildcarded value.         The parameters that are passed textual strings can be given wildcard characters         (asterisk) at the beginning and/or end of the string. So, a product value of          "Photo*" will search for any product starting with "Photo". The same call without         the asterisk will match only the "Photo" product. Parameters that accept asterisk         wildcards are: Product, Version, build, and language. Passing just an asterisk          as a parameter value is not allowed.   3. Inequality values.         Parameters whose values represent part of an ordered range can accept =, >, <, >=,         and <= values as prefixes to the string value (i.e. ">Not Tested" as a certlevel          value). Specifying = as a prefix means the query will match only that value. The         parameters that accept inequality prefixes are:            CertLevel - Accepts all inequality values. If no inequality prefix is given                default behaviour is >= (selecting builds that have a certlevel greater than               or equal to the given value)            Date - Accepts all inequality values. If no inequality prefix is given, default                behaviour is <= (selecting builds that have a date on or before the given value.)   4. No value.         If a parameter is left blank (passed as an empty string), then it will not         be used as a filter, and builds can be returned matching any value for that parameter.      """      try:         result = self._server.GetLatestBuild(            productname  =  product,            versionname = version,            subproductname = subproduct,            buildname = build,            platformname = platform,            languagecode = language,            compilertargetname = compiletarget,            licensemodelname = licensing,            formatname = format,            certlevel = certlevel,            statusname = status,            date = date,            keyvalpair=metadata)      except Exception, e:         _handleException(e)      return _getBuildFromNode(result['build'])         def getBuilds(self, product='', version='', subproduct='', build='', platform='', language='', compiletarget='', licensing='',      format='', certlevel='', status='', date='', metadata=''):      """         get a list of Builds meeting specific criteria         product        String  Name of a current product         version        String  Name of a current version of the given product         build          String  Name of a current build of the given product         platform       String  Name of a current Platform in Codex         language       String  Name of a current language in Codex         compiletarget  String  Name of a valid compile target value         licensing      String  Name of a valid licensing value         format         String  Name of a valid format value         certlevel      String  Name of a valid Certification Level         status         String  Name of a valid status         date           String  A date to filter by, of the form YYYY/MM/DD or YYYY/MM/DD:HH:MM:SS (same as Perforce)         metadata       String  A set of key/value pairs concatenated together "key1=value1:key2=value2"      This is the most complex method in the API aside from addBuild. This is         the primary method for querying Codex for a set of builds with an arbitrary         set of parameters. As such, each parameter accepts a variety of values:   1. A fixed value.         The method will search the database for an exact match.   2. A wildcarded value.         The parameters that are passed textual strings can be given wildcard characters         (asterisk) at the beginning and/or end of the string. So, a product value of          "Photo*" will search for any product starting with "Photo". The same call without         the asterisk will match only the "Photo" product. Parameters that accept asterisk         wildcards are: Product, Version, build, and language. Passing just an asterisk          as a parameter value is not allowed.   3. Inequality values.         Parameters whose values represent part of an ordered range can accept =, >, <, >=,         and <= values as prefixes to the string value (i.e. ">Not Tested" as a certlevel          value). Specifying = as a prefix means the query will match only that value. The         parameters that accept inequality prefixes are:            CertLevel - Accepts all inequality values. If no inequality prefix is given                default behaviour is >= (selecting builds that have a certlevel greater than               or equal to the given value)            Date - Accepts all inequality values. If no inequality prefix is given, default                behaviour is <= (selecting builds that have a date on or before the given value.)   4. No value.         If a parameter is left blank (passed as an empty string), then it will not         be used as a filter, and builds can be returned matching any value for that parameter.      """      try:         result = self._server.GetBuilds(            productname  =  product,            versionname = version,            subproductname = subproduct,            buildname = build,            platformname = platform,            languagecode = language,            compilertargetname = compiletarget,            licensemodelname = licensing,            formatname = format,            certlevel = certlevel,            statusname = status,            date = date,            keyvalpair=metadata)      except Exception, e:         _handleException(e)      return _getBuildListFromNode(result['buildlist'])         def getFlatBuilds(self, product='', version='', subproduct='', build='', platform='', language='', compiletarget='', licensing='',      format='', certlevel='', status='', date='', metadata=''):      """         get a list of Builds meeting specific criteria         product        String  Name of a current product         version        String  Name of a current version of the given product         build          String  Name of a current build of the given product         platform       String  Name of a current Platform in Codex         language       String  Name of a current language in Codex         compiletarget  String  Name of a valid compile target value         licensing      String  Name of a valid licensing value         format         String  Name of a valid format value         certlevel      String  Name of a valid Certification Level         status         String  Name of a valid status         date           String  A date to filter by, of the form YYYY/MM/DD or YYYY/MM/DD:HH:MM:SS (same as Perforce)      This method works primarily like getBuilds, but with a few differences:      1.  It does not allow metadata searching.      2.  It does not return information on Sources, Metadata, or Notes.      3.  If a language parameter is not specified, the result may not list language attributes.      """      try:         result = self._server.GetFlatBuilds(            productname  =  product,            versionname = version,            subproductname = subproduct,            buildname = build,            platformname = platform,            languagecode = language,            compilertargetname = compiletarget,            licensemodelname = licensing,            formatname = format,            certlevel = certlevel,            statusname = status,            date = date)      except Exception, e:         _handleException(e)      return _getBuildListFromNode(result['flatbuildlist'])         def getBuildsCount(self, product='', version='', subproduct='', build='', platform='', language='', compiletarget='', licensing='',      format='', certlevel='', status='', date='', metadata=''):      """         get a count of the number of Builds meeting specific criteria         product        String  Name of a current product         version        String  Name of a current version of the given product         build          String  Name of a current build of the given product         platform       String  Name of a current Platform in Codex         language       String  Name of a current language in Codex         compiletarget  String  Name of a valid compile target value         licensing      String  Name of a valid licensing value         format         String  Name of a valid format value         certlevel      String  Name of a valid Certification Level         status         String  Name of a valid status         date           String  A date to filter by, of the form YYYY/MM/DD or YYYY/MM/DD:HH:MM:SS (same as Perforce)         metadata       String  A set of key/value pairs concatenated together "key1=value1:key2=value2"      This method follows the same rules as the getBuilds method for input parameters.  It outputs an integer.      """      try:         result = self._server.GetBuildsCount(            productname  =  product,            versionname = version,            subproductname = subproduct,            buildname = build,            platformname = platform,            languagecode = language,            compilertargetname = compiletarget,            licensemodelname = licensing,            formatname = format,            certlevel = certlevel,            statusname = status,            date = date,            keyvalpair = metadata)      except Exception, e:         _handleException(e)      return result['buildcount']         def getBuildsByLocation(self, protocol='', server='', path='', query=''):      """         get a list of Builds posted to a particular location                  protocol   String   Protocol to search for 'afp' 'ftp' 'smp' 'p4'         server     String   whole or partial server name to filter by         path       String   full or partial path to filter by         query      String   query value to filter by      The server and path parameters accept wildcarded values, meaning they can be given wildcard         characters (asterisk) at the beginning and/or end of the string. So, a server value of          "hermes*" will search for any server starting with "hermes". The same call without the          asterisk will match only the "hermes" server (and not "hermes.corp.adobe.com"). Passing         just an asterisk as a parameter value is not allowed.         If a parameter is left blank (passed as an empty string), then it will not be used as a          filter, and builds can be returned matching any value for that parameter.      """      try:         result = self._server.GetBuildsByLocation(protocol=protocol, servername=server, path=path, query=query)      except Exception, e:         _handleException(e)      return _getBuildListFromNode(result['buildlist'])         def getBuildsFromProfile(self, product, version, profile, componentproduct, componentsubproduct, platform, language):      """         get a list of Builds based on the contents of a profile               The parameters accept wildcarded values, meaning they can be given wildcard characters         (asterisk) at the beginning and/or end of the string. Passing just an asterisk as a          parameter value is not allowed.      If a parameter is left blank (passed as an empty string), then it will not be used as         a filter, and builds can be returned matching any value for that parameter.      """      try:         result = self._server.GetBuildsFromProfile(productname=product, versionname=version, profilename=profile,            component=componentproduct, subproductname=componentsubproduct, platformname=platform, languagecode=language)      except Exception, e:         _handleException(e)      return _getBuildListFromNode(result['buildlist'])   def getFlatBuildsFromProfile(self, product, version, profile, componentproduct, componentsubproduct, platform, language):      """         get a list of Builds based on the contents of a profile               The parameters accept wildcarded values, meaning they can be given wildcard characters         (asterisk) at the beginning and/or end of the string. Passing just an asterisk as a          parameter value is not allowed.      If a parameter is left blank (passed as an empty string), then it will not be used as         a filter, and builds can be returned matching any value for that parameter.      """      try:         result = self._server.GetFlatBuildsFromProfile(productname=product, versionname=version, profilename=profile,            component=componentproduct, subproductname=componentsubproduct, platformname=platform, languagecode=language)      except Exception, e:         _handleException(e)      return _getBuildListFromNode(result['flatbuildlist'])   def getBuildsFromProfileWithComponent(self, product, version, profile, componentproduct, componentsubproduct, platform, language, filtercomponent, filterbuild):      """         get a list of Builds based on the contents of a profile               The parameters accept wildcarded values, meaning they can be given wildcard characters         (asterisk) at the beginning and/or end of the string. Passing just an asterisk as a          parameter value is not allowed.      If a parameter is left blank (passed as an empty string), then it will not be used as         a filter, and builds can be returned matching any value for that parameter.      """      try:         result = self._server.GetBuildsFromProfileWithComponent(productname=product, versionname=version, profilename=profile,            component=componentproduct, subproductname=componentsubproduct, platformname=platform, languagecode=language,            filtercomponent=filtercomponent, buildname=filterbuild)      except Exception, e:         _handleException(e)      return _getBuildListFromNode(result['buildlist'])   def getBuildFromProfile(self, product, version, profile, componentproduct, componentsubproduct, platform, language):      """         get a build based on the contents of a profile               The parameters accept wildcarded values, meaning they can be given wildcard characters         (asterisk) at the beginning and/or end of the string. Passing just an asterisk as a          parameter value is not allowed.      If a parameter is left blank (passed as an empty string), then it will not be used as         a filter, and builds can be returned matching any value for that parameter.      """      try:         result = self._server.GetBuildFromProfile(productname=product, versionname=version, profilename=profile,            component=componentproduct, subproductname=componentsubproduct, platformname=platform, languagecode=language)      except Exception, e:         _handleException(e)      return _getBuildFromNode(result['build'])         def getFlatBuildFromProfile(self, product, version, profile, componentproduct, componentsubproduct, platform, language):      """         get a build based on the contents of a profile               The parameters accept wildcarded values, meaning they can be given wildcard characters         (asterisk) at the beginning and/or end of the string. Passing just an asterisk as a          parameter value is not allowed.      If a parameter is left blank (passed as an empty string), then it will not be used as         a filter, and builds can be returned matching any value for that parameter.      """      try:         result = self._server.GetFlatBuildFromProfile(productname=product, versionname=version, profilename=profile,            component=componentproduct, subproductname=componentsubproduct, platformname=platform, languagecode=language)      except Exception, e:         _handleException(e)      return _getBuildFromNode(result['flatbuild'])         def getAllBuildsFromProfile(self, product, version, profile, platform, language):      "get a list of all Builds in a profile, not filtered by comoponent"      try:         result = self._server.GetAllBuildsFromProfile(productname=product, versionname=version, profilename=profile,            platformname=platform, languagecode=language)      except Exception, e:         _handleException(e)      return _getBuildListFromNode(result['buildlist'])   def getAllFlatBuildsFromProfile(self, product, version, profile, platform, language):      "get a list of all Builds in a profile, not filtered by comoponent"      try:         result = self._server.GetAllFlatBuildsFromProfile(productname=product, versionname=version, profilename=profile,            platformname=platform, languagecode=language)      except Exception, e:         _handleException(e)      return _getBuildListFromNode(result['flatbuildlist'])   def getBuildComponents(self, id):      "returns a list of Builds used by the build having the passed in id"      id = int(id)      try:         result = self._server.GetBuildComponents(id=id)      except Exception, e:         _handleException(e)      return _getBuildListFromNode(result['buildlist'])         def getFlatBuildComponents(self, id, fetchLanguages):      "returns a list of Builds used by the build having the passed in id"      id = int(id)      try:         result = self._server.GetFlatBuildComponents(id=id, fetchlanguages=fetchLanguages)      except Exception, e:         _handleException(e)      return _getBuildListFromNode(result['flatbuildlist'])         def getBuildsUsing(self, id):      "returns a list of Builds using the build having the passed in id"      id = int(id)      try:         result = self._server.GetBuildsUsing(id=id)      except Exception, e:         _handleException(e)      return _getBuildListFromNode(result['buildlist'])   def getFlatBuildsUsing(self, id, fetchLanguages):      "returns a list of Builds using the build having the passed in id"      id = int(id)      try:         result = self._server.GetFlatBuildsUsing(id=id, fetchlanguages=fetchLanguages)      except Exception, e:         _handleException(e)      return _getBuildListFromNode(result['flatbuildlist'])   def getBuildByID(self, id):      "get a specific Build by id"      id = int(id)      try:         result = self._server.GetBuildById(buildid=id)      except Exception, e:         _handleException(e)      return _getBuildFromNode(result['build'])   def addBuild(self, manifestFile, URI, certlevel, status, username, password):      """         add a new build to codex; returns the id of the new build               pass the contents of the manifest.xml file as manifestFile      """      try:         manifestFile = self.__trimVersionInfo(manifestFile)         result = self._server.AddBuild(manifestfile=manifestFile,uri=URI,certlevel=certlevel,            statusname=status, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['id']         def addPart(self, manifestFile, status, URI, username, password):      """         add a new part to codex; returns the id of the new part               pass the contents of the manifest.xml file as manifestFile      """      try:         result = self._server.AddPart(manifestfile=manifestFile, statusname=status, uri=URI,            ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['id']      def addSet(self, manifestFile, certlevel, username, password):      """         add a new set to codex; returns the id of the new set               pass the contents of the manifest.xml file as manifestFile      """      try:         result = self._server.AddSet(manifestfile=manifestFile, certlevel=certlevel,            ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['id']            def addNote(self, id, text, username, password):      "add a note to a build (specified by id), returns the updated Build"      id = int(id)      try:         result = self._server.AddNote(buildid=id, notetext=text, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return _getBuildFromNode(result['build'])   def setCertLevel(self, id, certlevel, username, password):      "set the certification level of the build having a given id; returns the updated Build"      id = int(id)      try:         result = self._server.SetCertLevel(id=id, certlevel=certlevel, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return _getBuildFromNode(result['build'])   def setStatus(self, id, status, username, password):      "set the status of the build having a given id; returns the updated Build"      id = int(id)      try:         result = self._server.SetStatus(id=id, statusname=status, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return _getBuildFromNode(result['build'])   def addBuildLocation(self, id, URI, status, username, password):      "add a new location to an existing build.  Returns the new location ID"      id = int(id)      try:         result = self._server.AddBuildLocation(id=id, uri=URI, status=status, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['id']   def setLocation(self, id, URI, username, password):      "set the uri of the build having a given id; returns the updated Build"      id = int(id)      try:         result = self._server.SetLocation(id=id, uri=URI, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return _getBuildFromNode(result['build'])   def setPartLocation(self, id, URI, username, password):      "set the uri of the part having a given id; returns the updated Part"      id = int(id)      try:         result = self._server.SetPartLocation(id=id, uri=URI, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return _getPartFromNode(result['part'])   def setMetadata(self, id, key, value, username, password):      "sets a key value pair in the build having a given id; returns the updated Build"      id = int(id)      try:         result = self._server.SetMetadata(id=id, key=key, value=value, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return _getBuildFromNode(result['build'])   def deleteMetadata(self, id, key, username, password):      "deletes a key value pair from a build; returns boolean indicating success"      id = int(id)      try:         result = self._server.DeleteMetadata(id=id, key=key, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['operationresult']      def getMetadataKeys(self, product, version):      "Gets the list of metadata keys that have been defined in Codex for the given Product/Version"      try:         result = self._server.GetMetadataKeys(product=product, version=version)      except Exception, e:         _handleException(e)      return _getMetadataKeyListFromNode(result['metadatakeylist'])   def addMetadataKey(self, key, productids="", versionids="", subproductids="", platformids="", licenseids="", compilertargetids="", formatids="", languageids="", statusids="", certlevelids="", dateconstraint="", username="", password=""):      "Adds a new metadata key to Codex for the optionally given product/version. The new key is then available for any build for the given product and version."      try:         result = self._server.AddMetadataKey(key=key, productids=productids, versionids=versionids, subproductids=subproductids, platformids=platformids, licenseids=licenseids, compilertargetids=compilertargetids, formatids=formatids, languageids=languageids, statusids=statusids, certlevelids=certlevelids, dateconstraint=dateconstraint, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['id']   def deleteMetadataKey(self, id, username, password):      "deletes a key from Codex based on the key id; returns boolean indicating success"      id = int(id)      try:         result = self._server.DeleteMetadataKey(id=id, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['operationresult']      def deleteBuild(self, id, username, password):      "deletes a build from codex by id; returns boolean indicating success"      id = int(id)      try:         result = self._server.DeleteBuild(id=id, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['operationresult']      def deletePart(self, id, username, password):      "deletes a part from codex by id"      id = int(id)      try:         result = self._server.DeletePart(id=id, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['operationresult']   def getBuildHistory(self, id):      """         get a list of Builds representing the history of a specific build               """      try:         result = self._server.GetBuildHistory(id=id)      except Exception, e:         _handleException(e)      return _getBuildListFromNode(result['buildlist'])         def getLocationsByBuildID(self, id):      """         get a list of locations for a given build ID      """      try:         result = self._server.GetLocationsByBuildId(id=id)      except Exception, e:         _handleException(e)      return _getLocationDataListFromNode(result['locationlist'])      # Profiles   def getProfiles(self, product, version):      "Returns a list of ProfileData (metadata) records"      try:         result = self._server.GetProfiles(productname=product, versionname=version)      except Exception, e:         _handleException(e)      return _getProfileDataListFromNode(result['profiledatalist'])   def getProfilesAndRecords(self, product, version):      "Returns a list of Profiles (metadata) records"      try:         result = self._server.GetProfilesAndRecords(productname=product, versionname=version)      except Exception, e:         _handleException(e)      return _getProfileListFromNode(result['profilelist'])   def getProfileByName(self, product, version, name):      "returns the requested Profile object"      try:         result = self._server.GetProfileByName(profilename=name, productname=product, versionname=version)      except Exception, e:         _handleException(e)      return _getProfileFromNode(result['profile'])   def getProfileByID(self, id):      "returns the Profile object requested by id"      id = int(id)      try:         result = self._server.GetProfileById(profileid=id)      except Exception, e:         _handleException(e)      return _getProfileFromNode(result['profile'])   def addProfile(self, product, version, name, username, password):      "add a profile; returns the profile id"      try:         result = self._server.AddProfile(productname=product, versionname=version, profilename=name, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['profileid']   def setProfileParent(self, id, product, version, username, password):      "set the parent product of a profile given by id; returns the updated Profile"      id = int(id)      try:         result = self._server.SetProfileParent(id=id, productname=product, versionname=version, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return _getProfileFromNode(result['profile'])   def setProfileDescription(self, id, description, username, password):      "set the description of a profile given by id; returns the updated Profile"      id = int(id)      try:         result = self._server.SetProfileDescription(id=id, description=description, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return _getProfileFromNode(result['profile'])   def setProfileName(self, id, name, username, password):      "set the name of a profile given by id; returns the updated Profile"      id = int(id)      try:         result = self._server.SetProfileName(id=id, name=name, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return _getProfileFromNode(result['profile'])   def deleteProfile(self, id, username, password):      "delete a profile by id; returns boolean indicating success"      id = int(id)      try:         result = self._server.DeleteProfile(id=id, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['operationresult']   def cloneProfile(self, id, product, version, name, username, password):      "add a profile using the one specified by id as a template; returns the profile id"      id=int(id)      try:         result = self._server.CloneProfile(profileid=id, productname=product, versionname=version, profilename=name, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['profileid']   # Profile Record   def getProfileRecordByName(self, id, product, subproduct):      "fetch a ProfileRecord by profile id and product name"      try:         result = self._server.GetProfilerecordByName(productname=product, subproductname=subproduct, profileid=id)      except Exception, e:         _handleException(e)      return _getProfileRecordFromNode(result['profilerecord'])   def addProfileRecord(self, id, product, version, subproduct, username, password):      "add a profilerecord to the profile specified by id for the given product version; returns record id"      id=int(id)      try:         result = self._server.AddProfilerecord(productname=product, versionname=version, subproductname=subproduct, profileid=id, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['id']   def setProfileRecordToLatest(self, id, certlevel, compilertarget, licensing, format, username, password):      "sets a profilerecord given by id to reference the latest build having specified settings; returns ?? id"      id=int(id)      try:         result = self._server.SetProfilerecordToLatest(profilerecordid=id,             certlevel=certlevel, compilertargetname=compilertarget, licensemodelname=licensing,            formatname=format, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['id']   def setProfileRecordToBuild(self, id, build, compilertarget, licensing, format, username, password):      "sets a profilerecord given by id to reference a specfic build; returns ?? id"      id=int(id)      try:         result = self._server.SetProfilerecordToBuild(profilerecordid=id, buildname=build,             compilertargetname=compilertarget, licensemodelname=licensing, formatname=format, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['id']   def setProfileRecordToDefault(self, id, profile, username, password):      "sets a profilerecord given by id to reference another profile; returns ?? id"      id=int(id)      try:         result = self._server.SetProfilerecordToDefault(id=id, profilename=profile, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['id']   def deleteProfileRecord(self, id, username, password):      "delete a profile record by id; return boolean indicating success"      id = int(id)      try:         result = self._server.DeleteProfilerecord(id=id, ldapcredentials={'userid':username, 'password':password})      except Exception, e:         _handleException(e)      return result['operationresult']   def getNewData(self, product, version, target):      "fetch a ProfileRecord by profile id and product name"      olddataset = datatypes.OldDataSet(product, version, target)      try:         result = self._server.GetNewData(OldDataSet=olddataset)      except Exception, e:         _handleException(e)      return result      def __trimVersionInfo(self, manifestfile):      """              Removes component nodes from all of the primary build's components.              This is to reduce the size dramatically.      """      try:         import versioninfo         xmlobj = versioninfo.VersionInfo(manifestfile)         xmlobj.removeComponents()         return xmlobj.toXML()      except ImportError:         return manifestfileclass Query(object):   """      Class for parsing an XML Query result and getting back a list of build objects   """   def __init__(self, xmlstr):      """         Instantiate the class by parsing the xml and getting the list of build         objects.      """      # Read in the file and remove extra spaces and line breaks      querydoc = parseString(xmlstr)      query = querydoc.documentElement      query.normalize()      self.buildlist = []      buildnodelist = query.getElementsByTagName("build")      for buildnode in buildnodelist:         self.buildlist.append(self.Build(buildnode))   def builds(self, product=None):      """         Returns a list of Build objects, filtered by product name if necessary      """      if product == None:         return self.buildlist      else:         resultlist = []         for build in self.buildlist:            if build.product == product:               resultlist.append(build)         return resultlist   def simpleVersionStrings(self, product=None):      """         Returns a list of strings with simply the product name and version numbers.         Suitable for using in a VersionInfo.txt file or such.      """      resultlist = []      for build in self.builds(product):         text = "%s %s" % (build.product, build.version)         resultlist.append(text)      return resultlist   class Build(object):      """         Class for parsing a build DOM object read from a query object         returned from Codex web service.      """      def __init__(self, node):         """            Instantiate the class by parsing the buildnode and assigning variable            values based on the node's attributes.         """         self.node = node         self.product = node.getAttribute("product")         if node.hasAttribute("version"):            self.version = node.getAttribute("version")         else:            self.version_major = node.getAttribute("version_major")            self.version_minor = node.getAttribute("version_minor")            self.version_sub = node.getAttribute("version_sub")            self.version = "%s.%s.%s" % (self.version_major, self.version_minor,                                         self.version_sub)         self.version_build = node.getAttribute("version_build")         self.fullversion = "%s %s" % (self.version, self.version_build)         self.date = node.getAttribute("date").encode("ascii")         self.time = node.getAttribute("time").encode("ascii")         self.target = node.getAttribute("target").encode("ascii")         self.lang = node.getAttribute("lang").replace(" ", "").encode("ascii")         self.phase_major = node.getAttribute("phase_major").encode("ascii")         self.phase_minor = node.getAttribute("phase_minor").encode("ascii")         self.type = node.getAttribute("type").encode("ascii")         self.certification = node.getAttribute("certification").encode("ascii")         self.AdobeCode = node.getAttribute("AdobeCode").encode("ascii")         self.notes = node.getAttribute("notes").encode("ascii")         self.auditnumber = node.getAttribute("auditnumber").encode("ascii")         self.location = None         self.scheme = None         self.authority = None         self.path = None         self.query = None         for element in node.childNodes:            if element.tagName == "location":               self.scheme = element.getAttribute("scheme").encode("ascii")               self.authority = element.getAttribute("authority").encode("ascii")               self.path = element.getAttribute("path").encode("ascii")               self.query = element.getAttribute("query").encode("ascii")               self.location = "%s://%s%s%s" % (self.scheme, self.authority,                                                self.path, self.query)      def langtuple(self):         """            Return the languages this build supports as a tuple.         """         return self.lang.split(",")      def __str__(self):         """            Return string representation of the build object         """         str = "Product: %s\nVersion: %s\nBuild: %s\n" % (self.product, self.version, self.version_build)         str += "Target: %s\nLanguage: %s\nType: %s\n" % (self.target, self.lang, self.type)         str += "Location: %s\n" % (self.location)         return str## helper functions#def _handleException(exception):   "takes a ZSI.Exception and reraises a more specific type of exception if possible, based on the string"   s = exception.__str__()   if 'does not exist' in s: raise KeyError, s   elif 'No entity found for query' in s: raise KeyError, s   elif 'already exists' in s: raise NameError, s   elif 'InvalidNameException' in s: raise NameError, s   else: raise Exception, sdef _addOptionalAttributes(attributeDictionary, keylist):   "takes a dictionary and adds null strings as values for any missing keys"   for key in keylist:      if not attributeDictionary.has_key(key):         attributeDictionary[key]=''def _getProductListFromNode(node):   'returns a list of Products when passed an xml node representing a productlist'   try:        productNodes = node['product']   except KeyError:      productNodes = []   productList = []   for productNode in productNodes:      productList.append(_getProductFromNode(productNode))   return productListdef _getProductFromNode(node):   'returns a Product when passed an xml node representing a product'   attrs = vars(node)   return datatypes.Product(attrs['_name'], attrs['_type'], attrs['_id'], attrs['link'], attrs.get('description', None), attrs.get('sapcode', None), attrs.get('watsonproduct', None), attrs.get('watsonfamily', None), attrs.get('latestversionid',""), attrs['_deprecated'])def _getSubproductListFromNode(node):   'returns a list of Subproducts when passed an xml node representing a subproductlist'   try:        childNodes = node['subproduct']   except KeyError:      childNodes = []   resultList = []   for child in childNodes:      resultList.append(_getSubproductFromNode(child))   return resultListdef _getSubproductFromNode(node):   'returns a Subroduct when passed an xml node representing a product'   attrs = vars(node)   return datatypes.Subproduct(attrs['_id'], attrs['_name'], attrs.get('description', None))def _getVersionListFromNode(node):   'return a list of Versions when passed an xml node representing a versionlist'   try:      versionNodes = node['version']   except KeyError:      versionNodes = []   versionList = []   for versionNode in versionNodes:      versionList.append(_getVersionFromNode(versionNode))   return versionListdef _getVersionFromNode(node):   'return a Version when passed an xml node representing a version'   attrs = vars(node)   #optional attributes   _addOptionalAttributes(attrs, ['_codename', '_unified_id'])   return datatypes.Version(attrs['_product'], attrs['_name'], attrs['_codename'], attrs['_id'], attrs['_unified_id'],      node['link'], node['description'])def _getCertLevelListFromNode(node):   'return a list of CertLevels when passed an xml node representing a certificationlevellist'   resultlist = []   try:        childNodes = node['certificationlevel']   except KeyError:      childNodes = []   for child in childNodes:      resultlist.append(_getCertLevelFromNode(child))   return resultlistdef _getCertLevelFromNode(node):   'return a CertLevel when passed an xml node representing a version'   attrs = vars(node)   #optional attributes   _addOptionalAttributes(attrs, ['_color'])   return datatypes.CertLevel(attrs['_name'], attrs['_id'], attrs['_color'])def _getStatusListFromNode(node):   'return a list of Statuses when passed an xml node representing a statuslist'   resultlist = []   try:        childNodes = node['status']   except KeyError:      childNodes = []   for child in childNodes:      resultlist.append(_getStatusFromNode(child))   return resultlistdef _getStatusFromNode(node):   'return a Status when passed an xml node representing a status'   attrs = vars(node)   return datatypes.Status(attrs['_name'], attrs['_id'], attrs['_isavailable'])def _getCompilerTargetListFromNode(node):   'return a list of CompilerTargets when passed an xml node representing a compilertargetlist'   resultlist = []   try:        childNodes = node['compilertarget']   except KeyError:      childNodes = []   for child in childNodes:      resultlist.append(_getCompilerTargetFromNode(child))   return resultlistdef _getCompilerTargetFromNode(node):   'return a CompilerTarget when passed an xml node representing a compilertarget'   attrs = vars(node)   return datatypes.CompilerTarget(attrs['_name'], attrs['_id'])def _getLicenseModelListFromNode(node):   'return a list of LicenseModels when passed an xml node representing a licensemodellist'   resultlist = []   try:        childNodes = node['licensemodel']   except KeyError:      childNodes = []   for child in childNodes:      resultlist.append(_getLicenseModelFromNode(child))   return resultlistdef _getLicenseModelFromNode(node):   'return a LicenseModel when passed an xml node representing a licensemodel'   attrs = vars(node)   return datatypes.LicenseModel(attrs['_name'], attrs['_id'])def _getFormatListFromNode(node):   'return a list of Formats when passed an xml node representing a formatlist'   resultlist = []   try:        childNodes = node['format']   except KeyError:      childNodes = []   for child in childNodes:      resultlist.append(_getFormatFromNode(child))   return resultlistdef _getFormatFromNode(node):   'return a Format when passed an xml node representing a format'   attrs = vars(node)   return datatypes.Format(attrs['_name'], attrs['_id'])def _getPlatformListFromNode(node):   'return a list of Platforms when passed an xml node representing a platformlist'   resultlist = []   try:        childNodes = node['platform']   except KeyError:      childNodes = []   for child in childNodes:      resultlist.append(_getPlatformFromNode(child))   return resultlistdef _getPlatformFromNode(node):   'return a Platform when passed an xml node representing a platform'   attrs = vars(node)   #optional attributes   _addOptionalAttributes(attrs, ['_description'])   return datatypes.Platform(attrs['_name'], attrs['_id'], attrs['_description'])def _getServerListFromNode(node):   'return a list of Servers when passed an xml node representing a serverlist'   resultlist = []   try:        childNodes = node['server']   except KeyError:      childNodes = []   for child in childNodes:      resultlist.append(_getServerFromNode(child))   return resultlistdef _getServerFromNode(node):   'return a Server when passed an xml node representing a server'   attrs = vars(node)   _addOptionalAttributes(attrs, ['_name'])   return datatypes.Server(attrs['_name'], attrs['_id'], attrs.get('webname', None))def _getLanguageListFromNode(node):   'return a list of Languages when passed an xml node representing a languagelist'   resultlist = []   try:        childNodes = node['language']   except KeyError:      childNodes = []   for child in childNodes:      resultlist.append(_getLanguageFromNode(child))   return resultlistdef _getLanguageFromNode(node):   'return a Language when passed an xml node representing a language'   attrs = vars(node)   #optional attributes   _addOptionalAttributes(attrs, ['_code'])   return datatypes.Language(attrs['_name'], attrs['_id'], attrs['_code'])def _getProductTypeListFromNode(node):   'return a list of ProductTypes when passed an xml node representing a producttypelist'   resultlist = []   try:        childNodes = node['producttype']   except KeyError:      childNodes = []   for child in childNodes:      resultlist.append(_getProductTypeFromNode(child))   return resultlistdef _getProductTypeFromNode(node):   'return a ProductTypes when passed an xml node representing a producttype'   attrs = vars(node)   return datatypes.ProductType(attrs['_name'], attrs['_id'], attrs['_description'])def _getPickupOptionListFromNode(node):   'return a list of PickupOptions when passed an xml node representing a pickupoptionlist'   resultlist = []   try:        childNodes = node['pickupoption']   except KeyError:      childNodes = []   for child in childNodes:      resultlist.append(_getPickupOptionFromNode(child))   return resultlistdef _getPickupOptionFromNode(node):   'return a ProductTypes when passed an xml node representing a pickupoption'   attrs = vars(node)   return datatypes.PickupOption(attrs['_name'], attrs['_id'])def _getBuildListFromNode(node):   'return a list of Builds when passed an xml node representing a buildlist'   resultlist = []   try:      if 'build' in node:         childNodes = vars(node).get('build', ())      elif 'flatbuild' in node:         childNodes = vars(node).get('flatbuild', ())      else:         childNodes = ()   except KeyError:      childNodes = []   for child in childNodes:      resultlist.append(_getBuildFromNode(child))   return resultlistdef _getBuildFromNode(node):   'return a Build when passed an xml node representing a build'   attrs = vars(node)   result = datatypes.Build(attrs['_id'], attrs['_product'], attrs['_version'], attrs['_subproduct'], attrs.get('_build', None), attrs['_platform'],      attrs.get('_language', None), attrs['_compilertarget'], attrs['_licensemodel'], attrs.get('_format', None), attrs['_certlevel'],      attrs.get('_status', None), attrs.get('_date', None), attrs.get('_datemodified', None), attrs.get('_user', None))   # process sources   try:       sources = vars(attrs.get('sources', {})).get('source', ())       for source in sources:          source_attrs = vars(source)          # optional source attributes          _addOptionalAttributes (source_attrs, ['_path','_protocol','_query','_server'])          result.addSource(source_attrs['_protocol'], source_attrs['_server'], source_attrs['_path'], source_attrs['_query'])   except:       sources = None        #do nothing           # process location   location = attrs.get('location', None)   if location:      loc_attrs = vars(location)      # optional location attributes      _addOptionalAttributes(loc_attrs, ['_path','_protocol','_query','_server'])      result.addLocation(loc_attrs['_protocol'], loc_attrs['_server'], loc_attrs['_path'], loc_attrs['_query'])   # process notes   try:       notes = vars(attrs.get('notes', {})).get('note', ())       for note in notes:          note_attrs = vars(note)          # optional note attributes          _addOptionalAttributes(note_attrs, ['_id'])          result.addNote(note_attrs['_id'], note['value'])   except:       # do nothing       notes = None   # process metadata   try:       metadata = vars(attrs.get('metadata', {})).get('item', ())       for datum in metadata:          datum_attrs = vars(datum)          # optional metadata attributes          _addOptionalAttributes(datum_attrs, ['_id','_key','_value'])          result.addMetadata(datum_attrs['_id'], datum_attrs['_key'], datum_attrs['_value'])   except:       metadata = None          # process fileinfo   try:       fileinfo = vars(attrs.get('fileinfo', {})).get('file', ())       for f in fileinfo:          f_attrs = vars(f)          # optional fileinfo attributes          _addOptionalAttributes(f_attrs, ['_filename', '_size', '_md5'])          result.addFileInfo(f_attrs['_filename'], f_attrs['_size'], f_attrs['_md5'])   except:       fileinfo = None   # process parts   if len(attrs.get('partlist', {}).get('part', ()))!=0:       partlist = vars(attrs.get('partlist', {})).get('part', ())      for p in partlist:         p_attrs = vars(p)         partobj = datatypes.Part(p_attrs['_id'], p_attrs['_buildid'], p_attrs['_product'],          p_attrs['_version'], p_attrs['_subproduct'], p_attrs.get('_revision', None),         p_attrs['_partnumber'], p_attrs['_platform'], p_attrs.get('_language', None),          p_attrs['_compilertarget'], p_attrs['_licensemodel'], p_attrs.get('_format',None),          p_attrs.get('_status', None), p_attrs.get('_date', None),          p_attrs.get('_datemodified', None), p_attrs.get('_user', None))      # process location      p_location = p_attrs.get('location', None)      if p_location:         p_loc_attrs = vars(p_location)         # optional location attributes         _addOptionalAttributes(p_loc_attrs, ['_path','_protocol','_query','_server'])         partobj.addLocation(p_loc_attrs['_protocol'], p_loc_attrs['_server'],             p_loc_attrs['_path'], p_loc_attrs['_query'], p_loc_attrs['_uri'])      # process metadata      p_metadata = vars(vars(p).get('metadata', {})).get('item', ())      for p_datum in p_metadata:         p_datum_attrs = vars(p_datum)         # optional metadata attributes         _addOptionalAttributes(p_datum_attrs, ['_id','_key','_value'])         partobj.addMetadata(p_datum_attrs['_id'], p_datum_attrs['_key'], p_datum_attrs['_value'])      # process fileinfo      p_fileinfo = vars(vars(p).get('fileinfo', {})).get('file', ())      for p_f in p_fileinfo:         p_f_attrs = vars(p_f)         # optional fileinfo attributes         _addOptionalAttributes(p_f_attrs, ['_filename', '_size', '_md5'])         partobj.addFileInfo(p_f_attrs['_filename'], p_f_attrs['_size'], p_f_attrs['_md5'])      result.addPart(partobj)   return resultdef _getPartFromNode(node):   'return a Part when passed an xml node representing a part'   attrs = vars(node)      _addOptionalAttributes(attrs, ['_buildid'])   result = datatypes.Part(attrs['_id'], attrs['_buildid'], attrs['_product'],       attrs['_version'], attrs['_subproduct'], attrs.get('_revision', None),      attrs['_partnumber'], attrs['_platform'], attrs.get('_language', None),       attrs['_compilertarget'], attrs['_licensemodel'], attrs.get('_format',None),       attrs.get('_status', None), attrs.get('_date', None),       attrs.get('_datemodified', None), attrs.get('_user', None))   # process sources   if len(attrs.get('sources', {}))!=0:       sources = vars(attrs.get('sources', {})).get('source', ())      for source in sources:         source_attrs = source['_attrs']         # optional source attributes         _addOptionalAttributes (source_attrs, ['path','protocol','query','server'])         result.addSource(source_attrs['protocol'], source_attrs['server'], source_attrs['path'], source_attrs['query'])   # process location   p_attrs = attrs   p_location = p_attrs.get('location', None)   if p_location:      p_loc_attrs = vars(p_location)      # optional location attributes      _addOptionalAttributes(p_loc_attrs, ['_path','_protocol','_query','_server'])      result.addLocation(p_location['_protocol'], p_location['_server'], p_location['_path'], p_location['_query'], p_location['_uri'])         	         # process notes   if len(attrs.get('notes', {}))!=0:       notes = vars(attrs.get('notes', {})).get('note', ())      for note in notes:         note_attrs = note['_attrs']         # optional note attributes         _addOptionalAttributes(note_attrs, ['id'])         result.addNote(note_attrs['id'], note['_text'])	     # process metadata   if len(p_attrs.get('metadata', {}))!=0:       p_metadata = vars(p_attrs.get('metadata', {})).get('item', ())      for p_datum in p_metadata:	    p_datum_attrs = vars(p_datum)	    # optional metadata attributes	    _addOptionalAttributes(p_datum_attrs, ['_id','_key','_value'])	    result.addMetadata(p_datum_attrs['_id'], p_datum_attrs['_key'], p_datum_attrs['_value'])		    # process fileinfo      if len(p_attrs.get('fileinfo', {}))!=0:       p_fileinfo = vars(p_attrs.get('fileinfo', {})).get('file', ())      for p_f in p_fileinfo:	    p_f_attrs = vars(p_f)	    # optional fileinfo attributes	    _addOptionalAttributes(p_f_attrs, ['_filename', '_size', '_md5'])	    result.addFileInfo(p_f_attrs['_filename'], p_f_attrs['_size'], p_f_attrs['_md5'])		    return resultdef _getLocationDataListFromNode(node):   resultlist = []   try:        childNodes = node['location']   except KeyError:      childNodes = []   except TypeError:      childNodes = []   for child in childNodes:      resultlist.append(_getLocationDataFromNode(child))   return resultlistdef _getLocationDataFromNode(node):   'return a ProfileData object when passed an xml node representing profiledata'   attrs = vars(node)   #optional attributes   _addOptionalAttributes(attrs, ['_status','_protocol','_uri','_server','_locationid', '_query', '_path'])   return datatypes.Location(attrs['_locationid'], attrs['_query'], attrs['_path'], attrs['_server'], attrs['_uri'], attrs['_protocol'], attrs['_status'])def _getProfileDataListFromNode(node):   'return a list of ProfileData objects when passed an xml node representing a profiledatalist'   resultlist = []   try:        childNodes = node['profiledata']   except KeyError:      childNodes = []   except TypeError:      childNodes = []   for child in childNodes:      resultlist.append(_getProfileDataFromNode(child))   return resultlistdef _getProfileDataFromNode(node):   'return a ProfileData object when passed an xml node representing profiledata'   attrs = vars(node)   #optional attributes   _addOptionalAttributes(attrs, ['_description','_parentproduct','_parentversion','_product','_version'])   return datatypes.ProfileData(attrs['_name'], attrs['_product'], attrs['_version'], attrs['_id'], attrs['_description'],      attrs['_parentproduct'], attrs['_parentversion'])def _getProfileListFromNode(node):   'return a list of Profile objects when passed an xml node representing a profilelist'   resultlist = []   try:        childNodes = node['profile']   except KeyError:      childNodes = []   for child in childNodes:      resultlist.append(_getProfileFromNode(child))   return resultlistdef _getProfileFromNode(node):   'return a Profile object when passed an xml node representing profile'   attrs = vars(node)   #optional attributes   _addOptionalAttributes(attrs, ['_description','_parentproduct','_parentversion','_product','_version'])   # get the profilerecords from this profile   profileRecordsList = []   if len(attrs.get('profilerecords', {}))!=0:       for child in vars(attrs.get('profilerecords', {})).get('profilerecord', ()):         profileRecordsList.append(_getProfileRecordFromNode(child))   return datatypes.Profile(attrs['_name'], attrs['_product'], attrs['_version'], attrs['_id'], attrs['_description'],      attrs['_parentproduct'], attrs['_parentversion'], profileRecordsList)def _getProfileRecordFromNode(node):   'return a ProfileRecord when passed an xml node representing a profilerecord'   attrs = vars(node)   #optional attributes   _addOptionalAttributes(attrs, ['certlevel','compiletarget','format','licensemodel','parentprofile','pickupoption'])   return datatypes.ProfileRecord(attrs['_id'], attrs['_profileid'], attrs['_product'], attrs['_version'], attrs['_subproduct'],       attrs['_pickupoption'], attrs['_certlevel'], attrs['_compiletarget'], attrs['_licensemodel'], attrs['_format'],      attrs.get('build', None), attrs.get('parentprofile', None))def _getMetadataKeyListFromNode(node):   'return a list of MetadataKeys when passed an xml node representing a list of MetadataKey'   resultlist = []   try:        childNodes = node['metadatakey']   except KeyError:      childNodes = []   for child in childNodes:      resultlist.append(_getMetadataKeyFromNode(child))   return resultlistdef _getMetadataKeyFromNode(node):   'return a MetadataKey when passed an xml node representing a metadata key-value pair'   attrs = vars(node)   #optional attributes   _addOptionalAttributes(attrs, ['product','version'])   return datatypes.MetadataKey(node['key'], node['id'], attrs['product'], attrs['version'])def _getPlatformGroupListFromNode(node):   'return a list of PlatformGroups when passed an xml node representing a platformgrouplist'   resultlist = []   try:        childNodes = node['platformgroup']   except KeyError:      childNodes = []   except TypeError:      childNodes = []   for child in childNodes:      resultlist.append(_getPlatformGroupFromNode(child))   return resultlistdef _getPlatformGroupFromNode(node):   'return a PlatformGroup when passed an xml node representing a platformgroup'   attrs = vars(node)   # get the platformgrouprecords from this profile   platformgroupRecordsList = []   if len(vars(node).get('platformgrouprecordlist', {})) != 0:      for child in vars(vars(node).get('platformgrouprecordlist', {})).get('platformgrouprecord', ()):         platformgroupRecordsList.append(_getPlatformgroupRecordFromNode(child))   return datatypes.PlatformGroup(attrs['_name'], attrs['_id'], attrs['_product'], attrs['_version'], platformgroupRecordsList)def _getPlatformgroupRecordFromNode(node):   'return a PlatformGroupRecord when passed an xml node representing a platformgrouprecord'   attrs = vars(node)   return datatypes.PlatformGroupRecord(attrs['_recordid'], attrs['_groupid'], attrs['_platform'])def _getContactListFromNode(node):   'return a list of Contacts when passed an xml node representing a contactlist'   resultlist = []   try:        childNodes = node['contact']   except KeyError:      childNodes = []   for child in childNodes:      resultlist.append(_getContactFromNode(child))   return resultlistdef _getContactFromNode(node):   'return a Contact when passed an xml node representing a contact'   attrs = vars(node)   return datatypes.Contact(attrs['_name'], attrs['_id'], attrs['_type'])def _getContactTypeListFromNode(node):   'return a list of ContactTypes when passed an xml node representing a contacttypelist'   resultlist = []   try:        childNodes = node['contacttype']   except KeyError:      childNodes = []   for child in childNodes:      resultlist.append(_getContactTypeFromNode(child))   return resultlistdef _getContactTypeFromNode(node):   'return a Contact when passed an xml node representing a contact'   attrs = vars(node)   return datatypes.ContactType(attrs['_name'], attrs['_id'])## self-test functions#def printProducts():   """      calls getProducts() and formats the response   """   result = codex.getProducts()   for res in result:           print res._name, res._type, res._id, res._link, res._descriptiondef printProduct(result):   """      prints the result of getProductByName or getProductByID   """   print "Name: %s (ID: %d)" % (result._name, result._id)   print "Type: %s" % (result._type)   print "Link: %s" % (result._link)   print "Description: %s" % (result._description)def printBuildId(result):   """      Prints out just a build id from functions that return it   """   print "%d" % (result['buildid'])if __name__ == "__main__":   # These lines need to be done for all the examples below   if len(sys.argv) > 1:      tracefile = sys.argv[1]      trace = open(tracefile, "w")      tracer = 1   else:      trace = None      tracer = 0   # instantiate the class   codex = CodexService(trace)   """   manifest = open("codex1.xml").read()   uri = "ftp://hermes.corp.adobe.com/Photoshop/10.0/blah/blah/blah"   certlevel = "Not Tested"   status = "Available"   """   username = ""   password = ""   product = "Web Premium"   version = "CS5"   subproduct = "Application"   profile = "English_Win Builds"   platform = "win32"   language = "en_US"   certlevel = "Not Tested"   #result = codex.getProducts()   #for res in result:   #   print res._name   #result = codex.getSubproducts(product, version)   #for res in result:   #   print res._name   #result = codex.getBuilds(product, version, subproduct, platform=platform, language=language)   #for res in result:   #   print res._id, res._product, res._version, res._subproduct, res._build, res._format, res._licensemodel   #print "---------------------"   #result = codex.getFlatBuilds(product, version, subproduct, build='369', platform=platform, language=language)   #for res in result:   #   print res._id, res._product, res._version, res._subproduct, res._build, res._location   #result = codex.getBuildsCount(product, version, subproduct, build='', platform=platform, language=language)   #print result   #result = codex.getBuildsCount(product, version, subproduct, build='', platform=platform, language=language, metadata="AdobeCode={BA8AD45D-79A7-4F79-9876-88A7402602B3}")   #print result   #result = codex.getLatestBuild(product, version, subproduct='', build='', platform=platform, language=language, compiletarget='', licensing='',   #  format='', certlevel=certlevel)   #print result._id, result._product, result._version, result._subproduct, result._build   #result = codex.getProfileByName(product, version, profile)   #print result   #result = codex.queryProductTypes()   #print result   #result = codex.getNewData(product, version, target)   #print result   #result = codex.getBuildsByLocation("", "pele.corp.adobe.com", "*builds/DesignStdSuite/CS4/Mac/en_US/20080413.m.200/Images/Retail", "")   #for res in result:   #   print res._id, res._product, res._version, res._subproduct, res._build   #result = codex.getBuildHistory(332626)   #for res in result:   #   print res._user, res._certlevel, res._datemodified   #result = codex.getAllBuildsFromProfile("Design Premium", "CS5", "RootWin", "win32", "en_US")   #for res in result:   #   print res._id, res._product, res._version, res._subproduct, res._build, res._location   #print "---------------------"   #result = codex.getAllFlatBuildsFromProfile("Design Premium", "CS5", "RootWin", "win32", "en_US")   #for res in result:   #   print res._id, res._product, res._version, res._subproduct, res._build, res._location   #result = codex.addMetadataKey("APP_jobStatus_Store", formatids="8,9,11,16,17,18", username=username, password=password)   #idlist = (1029143,)   #for id in idlist:      #res = codex.getBuildByID(id)      #print res._id, res._product, res._version, res._subproduct, res._build, res._platform, res._language, res._compilertarget, res._format, res._fileinfo, res._location      #lres = codex.getLocationsByBuildID(id)      #print lres      #uri = 'ftp://indstore.corp.adobe.com/builds01/webpremium/CS5/Application/win32/English/655.0/Retail/RIBSInstaller/'      #result = codex.addBuildLocation(id, uri, 'Available', username, password)      #print result   #   for p in res._partlist:   #      print p._partnumber   #      print p._location['uri']   #printProducts()   #printProduct(codex.getProductByName("GoogleMaps"))   #printProduct(codex.getProductByID(11))   #printBuildId(codex.queryDependencyComponent("Photoshop", "10.0", "osx10", "Bridge", "en_US"))   if tracer:      trace.close()   sys.exit()